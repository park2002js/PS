# 문제 16953

## 📌 문제 설명
### 지문
정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.
- 2를 곱한다.
- 1을 수의 가장 오른쪽에 추가한다. 
A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.

### 입력
첫째 줄에 A, B (1 ≤ A < B ≤ 109)가 주어진다.

### 출력
A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.

## ✅ 풀이 현황
- [ ] C
- [x] C++
- [ ] C#
- [ ] Python

## 🧠 풀이 요약
첫 접근은 A(이하 "출발지")에서 *2나 *10+1 의 경우를 전부 따져서 B(이하 "목적지")가 되는 경우를 찾는 방향으로 하였다.
이를 구현하기 위해선 DFS등을 활용해 B를 넘어서는 경우를 제외한 모든 경우에 대해 해답이 존재하면 답을 출력하고, 
하나도 존재하지 않으면 -1을 출력하면 된다고 생각하였다.

그러나 이건 너무 복잡하고, 구현하기가 어려울 것 같아 패턴을 찾아보기로 했다.

B에서 A로 가는 방법을 찾아보던 중, 정수에서 2가지 연산 중 하나로 현재의 값이 되는 경우는 
"현재의 값이 2의 배수거나", "현재의 값에서 1을 빼고 10을 나눴을 때 정수가 되"는 경우 둘 중에 하나임을 발견했고, 두 가지 모두가 가능한 경우는 존재하지 않는다는 것까지 알게 되었다.

반복문을 통해, B을 2로 나누거나 -1하고 10으로 나누었을 때 정수가 되면 해당 연산을 수행하고, "A=B"가 되면 현재 연산 횟수를 출력, B가 A보다 작아지거나 그 외의 경우가 생기면(그런 경우가 있는지 모르겠지만) -1을 출력하고 종료하는 것으로 코드를 짰다.

현재 발견한 더 발전할 수 있는 요소는 다음과 같다.
- 반복문의 조건을 A!=B로 설정하여 A=B가 되면 자동으로 종료하게 하는 것으로 코드 길이를 줄일 수 있다는 점. 
- -1을 출력하는 모든 경우를 감지할 수 있는 조건을 찾아내서 반복문의 첫 if문으로 쓰면, 뒤의 두 연산을 진행하는 것을 if - else 한번으로 끝낼 수 있다는 점
- b를 1과 AND 비트연산을 하면 자동으로 마지막 자리 숫자를 알 수 있다는 점

과연 나중에 이 문제를 다시 풀게되면 위와 같은 점을 확인 할 수 있을지 궁금하다.